{"version":3,"sources":["../../src/hooks.ts","../../src/index.tsx","App.tsx","index.tsx"],"names":["useResponsiveSize","container","imgSize","resizeObserverRef","useRef","useState","size","setSize","handleResize","useCallback","clientWidth","clientHeight","width","height","aspect","useEffect","current","ResizeObserver","observe","containerSize","React","canvasSize","setCanvasSize","newImgHeight","isWidest","useCanvasResolution","NOOP","GRID_STYLES","strokeStyle","lineDashOffset","lineDash","SELECT_AREA_STYLES","fillStyle","CELLS_STYLES","SelectableGrid","cellSize","_ref$cellSize","onMouseDown","onMouseMove","onMouseUp","gridStyles","selectAreaStyles","cellsStyles","canvasRef","canvasStyles","top","left","right","bottom","setCanvasStyles","containerWidth","offsetWidth","containerHeight","offsetHeight","canvasWidth","canvasHeight","offsetX","offsetY","useCanvasStyles","paddings","setPaddings","cellCountX","Math","floor","paddingTop","paddingLeft","useCanvasPaddings","isDrag","setIsDrag","startPoint","setStartPoint","x","y","w","h","area","setArea","areaInPx","setAreaInPx","areaInPercent","setAreaInPercent","pLeft","pTop","handleMouseDown","event","nativeEvent","point","handleMouseMove","min","abs","handleMouseUp","useMouseCallbacks","drawGrid","ctx","getContext","clearRect","setLineDash","beginPath","moveTo","lineTo","stroke","drawSelectArea","strokeRect","fillRect","fillCells","startX","endX","ceil","startY","countX","countY","cellX","cellY","positionX","CELL_OFFSET","positionY","ref","className","styles","style","App","containerRef","imgRef","undefined","setImgSize","src","alt","onLoad","currentTarget","naturalWidth","naturalHeight","e","downPosition","console","log","areaInfo","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.776c3e59.chunk.js","sourcesContent":["import React, { useCallback, useEffect, useRef, useState } from 'react'\n\nimport {\n  Size,\n  CanvasSize,\n  Paddings,\n  Point,\n  SelectableArea,\n  AreaInPx,\n  AreaInPercent,\n  AreaInfo\n} from './types'\n\n// set canvas size\nexport const useCanvasResolution = ({\n  containerSize,\n  imgSize\n}: {\n  containerSize?: Size\n  imgSize?: Size\n}) => {\n  const [canvasSize, setCanvasSize] = React.useState<CanvasSize>({\n    width: 0,\n    height: 0\n  })\n\n  useEffect(() => {\n    if (!containerSize || !imgSize) {\n      return\n    }\n\n    const { width, height } = containerSize\n    const { aspect } = imgSize\n\n    const newImgWidth = height * aspect\n    const newImgHeight = width / aspect\n\n    const isWidest = newImgHeight <= height\n\n    const size = {\n      width: isWidest ? width : newImgWidth,\n      height: isWidest ? newImgHeight : height\n    }\n\n    setCanvasSize(size)\n  }, [containerSize, imgSize])\n\n  return canvasSize\n}\n\n// set paddings for grid\nexport const useCanvasPaddings = ({\n  canvasSize,\n  cellSize\n}: {\n  canvasSize: CanvasSize\n  cellSize: number\n}) => {\n  const [paddings, setPaddings] = React.useState<Paddings>({\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0\n  })\n\n  useEffect(() => {\n    const { width, height } = canvasSize\n\n    if (!width || !height) {\n      return\n    }\n\n    const cellCountX = Math.floor(width / cellSize)\n    const cellCountY = Math.floor(height / cellSize)\n\n    const paddingX = width - cellCountX * cellSize\n    const paddingY = height - cellCountY * cellSize\n\n    const paddingTop = paddingY / 2 - 0.5\n    const paddingLeft = paddingX / 2 - 0.5\n    const paddingRight = paddingLeft\n    const paddingBottom = paddingTop\n\n    setPaddings({\n      top: paddingTop,\n      left: paddingLeft,\n      right: paddingRight,\n      bottom: paddingBottom\n    })\n  }, [canvasSize, cellSize])\n\n  return paddings\n}\n\n// set canvas styles\nexport const useCanvasStyles = ({\n  container,\n  canvasSize\n}: {\n  container: HTMLDivElement | null\n  canvasSize: CanvasSize\n}) => {\n  const [canvasStyles, setCanvasStyles] = React.useState({\n    top: '0',\n    left: '0',\n    right: '0',\n    bottom: '0'\n  })\n\n  useEffect(() => {\n    if (!container || !canvasSize.width || !canvasSize.height) {\n      return\n    }\n\n    const { offsetWidth: containerWidth, offsetHeight: containerHeight } =\n      container\n    const { width: canvasWidth, height: canvasHeight } = canvasSize\n\n    const isOffsetX = canvasWidth <= containerWidth\n    const isOffsetY = canvasHeight <= containerHeight\n\n    const offsetX = isOffsetX ? (containerWidth - canvasWidth) / 2 : 0\n    const offsetY = isOffsetY ? (containerHeight - canvasHeight) / 2 : 0\n\n    const styles = {\n      top: `${(offsetY / containerHeight) * 100}%`,\n      left: `${(offsetX / containerWidth) * 100}%`,\n      right: `${(offsetX / containerWidth) * 100}%`,\n      bottom: `${(offsetY / containerHeight) * 100}%`\n    }\n\n    setCanvasStyles(styles)\n  }, [container, canvasSize])\n\n  return canvasStyles\n}\n\nexport const useMouseCallbacks = ({\n  onMouseDown,\n  onMouseMove,\n  onMouseUp,\n  paddings,\n  canvasSize,\n  cellSize\n}: {\n  onMouseDown: (e: React.MouseEvent, downPosition: Point) => void\n  onMouseMove: (e: React.MouseEvent, areaInfo: AreaInfo) => void\n  onMouseUp: (e: React.MouseEvent, areaInfo: AreaInfo) => void\n  paddings: Paddings\n  canvasSize: CanvasSize\n  cellSize: number\n}) => {\n  const [isDrag, setIsDrag] = React.useState<boolean>(false)\n  const [startPoint, setStartPoint] = React.useState<Point | null>(null)\n  const [area, setArea] = React.useState<SelectableArea>({\n    x: 0,\n    y: 0,\n    w: 0,\n    h: 0\n  })\n  const [areaInPx, setAreaInPx] = React.useState<AreaInPx>({\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0\n  })\n\n  const [areaInPercent, setAreaInPercent] = React.useState<AreaInPercent>({\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0\n  })\n\n  // calculate selected area in px and percent\n  useEffect(() => {\n    const { x, y, w, h } = area\n    const { left: pLeft, top: pTop } = paddings\n    const { width, height } = canvasSize\n\n    const left = Math.floor((x - pLeft) / cellSize) * cellSize + pLeft\n    const top = Math.floor((y - pTop) / cellSize) * cellSize + pTop\n    const right =\n      Math.floor((x + w - pLeft) / cellSize) * cellSize + pLeft + cellSize\n    const bottom =\n      Math.floor((y + h - pTop) / cellSize) * cellSize + pTop + cellSize\n\n    setAreaInPx({ top, left, right, bottom })\n    setAreaInPercent({\n      top: top / height,\n      left: left / width,\n      right: right / width,\n      bottom: bottom / height\n    })\n  }, [area, paddings, canvasSize, cellSize])\n\n  // reset selectable area when canvas changing own sizes\n  useEffect(() => {\n    setIsDrag(false)\n    setStartPoint(null)\n  }, [canvasSize])\n\n  const handleMouseDown = (event: React.MouseEvent) => {\n    const {\n      nativeEvent: { offsetX, offsetY }\n    } = event\n\n    const point = { x: offsetX, y: offsetY }\n\n    setIsDrag(true)\n    setStartPoint(point)\n    setArea({ ...point, w: 0, h: 0 })\n    onMouseDown(event, point)\n  }\n\n  const handleMouseUp = (event: React.MouseEvent) => {\n    setIsDrag(false)\n    onMouseUp(event, { area, areaInPx, areaInPercent })\n  }\n\n  const handleMouseMove = (event: React.MouseEvent) => {\n    const {\n      nativeEvent: { offsetX, offsetY }\n    } = event\n\n    if (!isDrag) {\n      return\n    }\n\n    if (!startPoint) {\n      return\n    }\n\n    const area = {\n      x: Math.min(offsetX, startPoint.x),\n      y: Math.min(offsetY, startPoint.y),\n      w: Math.abs(offsetX - startPoint.x),\n      h: Math.abs(offsetY - startPoint.y)\n    }\n\n    setArea(area)\n\n    onMouseMove(event, { area, areaInPx, areaInPercent })\n  }\n\n  return {\n    isDrag,\n    area,\n    startPoint,\n    handleMouseDown,\n    handleMouseMove,\n    handleMouseUp\n  }\n}\n\nexport const useResponsiveSize = ({\n  container,\n  imgSize\n}: {\n  container: HTMLDivElement | null\n  imgSize?: Size\n}) => {\n  const resizeObserverRef = useRef<ResizeObserver>()\n  const [size, setSize] = useState<{\n    width: number\n    height: number\n    aspect: number\n  }>()\n\n  const handleResize = useCallback(() => {\n    if (!container) {\n      return\n    }\n\n    const { clientWidth, clientHeight } = container\n\n    setSize({\n      width: clientWidth,\n      height: clientHeight,\n      aspect: clientWidth / clientHeight\n    })\n  }, [container])\n\n  useEffect(() => {\n    if (!resizeObserverRef.current && container) {\n      resizeObserverRef.current = new ResizeObserver(handleResize)\n      resizeObserverRef.current.observe(container)\n    }\n  }, [container, handleResize])\n\n  const canvasSize = useCanvasResolution({ containerSize: size, imgSize })\n\n  return canvasSize\n}\n","import * as React from 'react'\n\nimport {\n  useCanvasPaddings,\n  useCanvasStyles,\n  useMouseCallbacks,\n  useResponsiveSize\n} from './hooks'\nimport { Size, Point, AreaInfo, CtxStyles } from './types'\nimport styles from './styles.module.css'\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nconst NOOP = () => {}\n\nconst GRID_STYLES = {\n  strokeStyle: 'blue',\n  lineDashOffset: 0,\n  lineDash: [5, 5]\n}\n\nconst SELECT_AREA_STYLES = {\n  strokeStyle: 'red',\n  fillStyle: 'rgba(100,0,0,0.3)',\n  lineDash: [0, 0]\n}\n\nconst CELLS_STYLES = {\n  strokeStyle: 'red',\n  fillStyle: 'rgba(100,0,0,0.3)'\n}\ninterface Props {\n  container: HTMLDivElement | null\n  imgSize?: Size\n  cellSize?: number\n  onMouseDown?: (e: React.MouseEvent, startDownPosition: Point) => void\n  onMouseMove?: (e: React.MouseEvent, areaInfo: AreaInfo) => void\n  onMouseUp?: (e: React.MouseEvent, areaInfo: AreaInfo) => void\n  gridStyles?: {\n    strokeStyle?: CtxStyles['strokeStyle']\n    lineDashOffset?: CtxStyles['lineDashOffset']\n    lineDash?: CtxStyles['lineDash']\n  }\n  selectAreaStyles?: {\n    strokeStyle?: CtxStyles['strokeStyle']\n    fillStyle?: CtxStyles['fillStyle']\n    lineDash?: CtxStyles['lineDash']\n  }\n  cellsStyles?: {\n    strokeStyle?: CtxStyles['strokeStyle']\n    fillStyle?: CtxStyles['fillStyle']\n  }\n}\n\nconst CELL_OFFSET = 5\n\nexport const SelectableGrid = ({\n  container,\n  imgSize,\n  cellSize = 30,\n  onMouseDown = NOOP,\n  onMouseMove = NOOP,\n  onMouseUp = NOOP,\n  gridStyles = GRID_STYLES,\n  selectAreaStyles = SELECT_AREA_STYLES,\n  cellsStyles = CELLS_STYLES\n}: Props) => {\n  const canvasRef = React.useRef<HTMLCanvasElement | null>(null)\n  const canvasSize = useResponsiveSize({ container, imgSize })\n  const canvasStyles = useCanvasStyles({ container, canvasSize })\n  const paddings = useCanvasPaddings({ canvasSize, cellSize })\n  const {\n    isDrag,\n    area,\n    handleMouseDown,\n    handleMouseMove,\n    handleMouseUp,\n    startPoint\n  } = useMouseCallbacks({\n    onMouseDown,\n    onMouseMove,\n    onMouseUp,\n    canvasSize,\n    cellSize,\n    paddings\n  })\n\n  const drawGrid = React.useCallback(() => {\n    if (!canvasRef.current) {\n      return\n    }\n\n    const ctx = canvasRef.current.getContext('2d')\n\n    if (!ctx) {\n      return\n    }\n\n    const { width, height } = canvasSize\n    const { top, left, right, bottom } = paddings\n\n    ctx.clearRect(0, 0, width, height)\n\n    ctx.strokeStyle = gridStyles.strokeStyle || GRID_STYLES.strokeStyle\n    ctx.setLineDash(gridStyles.lineDash || GRID_STYLES.lineDash)\n    ctx.lineDashOffset = gridStyles.lineDashOffset || GRID_STYLES.lineDashOffset\n\n    ctx.beginPath()\n\n    for (let x = left; x <= width - right; x += cellSize) {\n      ctx.moveTo(x, top)\n      ctx.lineTo(x, height - bottom)\n    }\n\n    for (let y = top; y <= height - bottom; y += cellSize) {\n      ctx.moveTo(left, y)\n      ctx.lineTo(width - right, y)\n    }\n\n    ctx.stroke()\n  }, [canvasSize, paddings, gridStyles, cellSize])\n\n  const drawSelectArea = React.useCallback(() => {\n    if (!canvasRef.current) {\n      return\n    }\n\n    const ctx = canvasRef.current.getContext('2d')\n\n    if (!ctx) {\n      return\n    }\n\n    ctx.strokeStyle =\n      selectAreaStyles.strokeStyle || SELECT_AREA_STYLES.strokeStyle\n    ctx.fillStyle = selectAreaStyles.fillStyle || SELECT_AREA_STYLES.fillStyle\n    ctx.setLineDash(selectAreaStyles.lineDash || SELECT_AREA_STYLES.lineDash)\n\n    const { x, y, w, h } = area\n\n    ctx.strokeRect(x, y, w, h)\n    ctx.fillRect(x, y, w, h)\n  }, [area, selectAreaStyles])\n\n  const fillCells = React.useCallback(() => {\n    if (!canvasRef.current) {\n      return\n    }\n\n    const ctx = canvasRef.current.getContext('2d')\n\n    if (!ctx) {\n      return\n    }\n\n    if (!startPoint) {\n      return\n    }\n\n    ctx.strokeStyle = cellsStyles.strokeStyle || CELLS_STYLES.strokeStyle\n    ctx.fillStyle = cellsStyles.fillStyle || CELLS_STYLES.fillStyle\n\n    const { x, y, w, h } = area\n    const { top, left, right, bottom } = paddings\n    const { width, height } = canvasSize\n\n    // TODO: To think about the algorithm for shading cells\n    const startX = Math.floor((x - left) / cellSize)\n    const endX = Math.ceil((x + w - left) / cellSize)\n    const startY = Math.floor((y - top) / cellSize)\n    const endY = Math.ceil((y + h - top) / cellSize)\n\n    const countX = endX - startX\n    const countY = endY - startY\n\n    for (let cellX = 0; cellX < countX; cellX += 1) {\n      for (let cellY = 0; cellY < countY; cellY += 1) {\n        const positionX =\n          Math.floor((x + cellSize * cellX - left) / cellSize) * cellSize +\n          left +\n          CELL_OFFSET / 2\n\n        const positionY =\n          Math.floor((y + cellSize * cellY - top) / cellSize) * cellSize +\n          top +\n          CELL_OFFSET / 2\n\n        // TODO: change the condition\n        if (\n          positionX < left ||\n          positionX > width - right ||\n          positionY < top ||\n          positionY > height - bottom\n        ) {\n          continue\n        }\n\n        ctx.clearRect(\n          positionX,\n          positionY,\n          cellSize - CELL_OFFSET,\n          cellSize - CELL_OFFSET\n        )\n        ctx.fillRect(\n          positionX,\n          positionY,\n          cellSize - CELL_OFFSET,\n          cellSize - CELL_OFFSET\n        )\n      }\n    }\n  }, [startPoint, cellsStyles, area, paddings, canvasSize, cellSize])\n\n  // all draws\n  React.useEffect(() => {\n    if (!canvasRef.current) {\n      return\n    }\n\n    const ctx = canvasRef.current.getContext('2d')\n\n    if (!ctx) {\n      return\n    }\n\n    ctx.clearRect(0, 0, canvasSize.width, canvasSize.height)\n\n    drawGrid()\n    fillCells()\n    if (isDrag) {\n      drawSelectArea()\n    }\n  }, [canvasSize, isDrag, drawGrid, fillCells, drawSelectArea])\n\n  if (!container || !imgSize) {\n    return null\n  }\n\n  return (\n    <canvas\n      ref={canvasRef}\n      className={styles.canvas}\n      style={{ ...canvasStyles }}\n      width={canvasSize.width}\n      height={canvasSize.height}\n      onMouseDown={handleMouseDown}\n      onMouseUp={handleMouseUp}\n      onMouseMove={handleMouseMove}\n    />\n  )\n}\n","import React, { useRef, useState } from 'react'\n\nimport { SelectableGrid } from 'selectable-grid'\nimport 'selectable-grid/dist/index.css'\nimport { Point, AreaInfo, Size } from '../../dist/types'\n\nconst App = () => {\n  const containerRef = useRef<HTMLDivElement>(null)\n  const imgRef = useRef<HTMLImageElement>(null)\n  const [imgSize, setImgSize] = useState<Size | undefined>(undefined)\n\n  const handleLoad = ({\n    currentTarget: { naturalWidth, naturalHeight }\n  }: React.SyntheticEvent<HTMLImageElement>) => {\n    setImgSize({\n      width: naturalWidth,\n      height: naturalHeight,\n      aspect: naturalWidth / naturalHeight\n    })\n  }\n\n  return (\n    <div ref={containerRef} className='container'>\n      <img\n        className='img'\n        ref={imgRef}\n        src='https://all-t-shirts.ru/goods_images/ru110593II00039d6336575d4ab6f3960422a337e0e78.jpg'\n        alt=''\n        onLoad={handleLoad}\n      />\n\n      <SelectableGrid\n        container={containerRef.current}\n        imgSize={imgSize}\n        onMouseDown={(e: React.MouseEvent, downPosition: Point) => {\n          console.log('event => ', e)\n          console.log('downPosition => ', downPosition)\n        }}\n        onMouseMove={(e: React.MouseEvent, areaInfo: AreaInfo) => {\n          console.log('event => ', e)\n          console.log('ðŸš€ ~ areaInfo', areaInfo)\n        }}\n        onMouseUp={(e: React.MouseEvent, areaInfo: AreaInfo) => {\n          console.log('event => ', e)\n          console.log('ðŸš€ ~ areaInfo', areaInfo)\n        }}\n      />\n    </div>\n  )\n}\n\nexport default App\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}